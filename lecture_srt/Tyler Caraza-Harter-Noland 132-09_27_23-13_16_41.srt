1
00:00:00,000 --> 00:00:01,920
We introduced this
idea of caching,

2
00:00:01,920 --> 00:00:04,440
which comes about because
we have different ways,

3
00:00:04,440 --> 00:00:05,700
places we can store by.

4
00:00:05,700 --> 00:00:07,700
Some are faster,
some are slower,

5
00:00:07,700 --> 00:00:10,319
and the faster ones
tend to be smaller.

6
00:00:10,319 --> 00:00:12,420
So what we'll often do
is have the majority of

7
00:00:12,420 --> 00:00:14,779
our data in one storage medium,

8
00:00:14,779 --> 00:00:16,259
and then we'll have
a subset of that

9
00:00:16,259 --> 00:00:18,100
in some faster technology.

10
00:00:18,100 --> 00:00:20,760
And that, of course,
raised a policy question.

11
00:00:20,760 --> 00:00:23,319
We have to have a policy
of what data gets to

12
00:00:23,319 --> 00:00:26,000
be logged in the
faster medium, right?

13
00:00:26,000 --> 00:00:26,939
And so we learned a couple of

14
00:00:26,939 --> 00:00:28,040
different policies last time.

15
00:00:28,040 --> 00:00:30,520
We learned Fifo and LRU.

16
00:00:30,520 --> 00:00:32,760
And today I want to spend a
little more time on those.

17
00:00:32,760 --> 00:00:34,519
Last time, you know, we ran out

18
00:00:34,519 --> 00:00:36,239
of time after the top
hat to go through it.

19
00:00:36,239 --> 00:00:38,639
So I'd go to go through that
a couple more examples.

20
00:00:38,639 --> 00:00:40,119
Try to understand
when these policies

21
00:00:40,119 --> 00:00:42,279
might work well or
when they might not.

22
00:00:42,279 --> 00:00:44,339
And then we're going to move to

23
00:00:44,339 --> 00:00:45,860
how could we actually write

24
00:00:45,860 --> 00:00:49,419
code to make this policy
a reality, right?

25
00:00:49,419 --> 00:00:51,859
So how could we write
code that does LRU,

26
00:00:51,859 --> 00:00:53,219
that's be setting you up.

27
00:00:53,219 --> 00:00:54,599
Well, for your project three

28
00:00:54,599 --> 00:00:56,759
that's be released this
Friday because there

29
00:00:56,759 --> 00:01:01,220
you're writing some
policy code for a cache.

30
00:01:01,220 --> 00:01:05,780
Then what I want to do is
I want to look at a new,

31
00:01:05,780 --> 00:01:08,180
well I guess it's
new to this course.

32
00:01:08,180 --> 00:01:11,480
I added a lecture this
semester on Pero.

33
00:01:11,480 --> 00:01:15,559
Pero is this Python package
that is cash aware.

34
00:01:15,559 --> 00:01:18,719
It tries to use a CPU cache
in a very efficient way.

35
00:01:18,719 --> 00:01:21,339
It lets you use such

36
00:01:21,339 --> 00:01:22,399
that the operating system is

37
00:01:22,399 --> 00:01:23,675
using in a very efficient way.

38
00:01:23,675 --> 00:01:25,829
So I want to give that type
of hands on like, okay,

39
00:01:25,829 --> 00:01:27,829
here's something practical you
could walk away with that,

40
00:01:27,829 --> 00:01:29,289
you could start taking

41
00:01:29,289 --> 00:01:31,169
advantage of some of these
things that we're learning.

42
00:01:31,169 --> 00:01:33,629
All right, so I might head
over here to my document

43
00:01:33,629 --> 00:01:37,810
Abra last time you
all did this problem.

44
00:01:37,810 --> 00:01:39,109
So I just want to work
through it and see

45
00:01:39,109 --> 00:01:41,309
if anybody has any
questions about it.

46
00:01:41,309 --> 00:01:43,390
There's a few things I see here.

47
00:01:43,390 --> 00:01:47,709
I see that we're doing a Fifo
cache and it's size three.

48
00:01:47,709 --> 00:01:49,250
And then this is our workload.

49
00:01:49,250 --> 00:01:50,630
And so the first thing
we have to do is

50
00:01:50,630 --> 00:01:52,389
we have to figure out
which ones are hits.

51
00:01:52,389 --> 00:01:54,729
And then from that we can
contribute a hit rate.

52
00:01:54,729 --> 00:01:56,549
And then based on
what the hit rate is,

53
00:01:56,549 --> 00:01:58,550
we could say, well, what
is the average latency?

54
00:01:58,550 --> 00:02:00,950
Because the hit has some
latency that's pretty fast.

55
00:02:00,950 --> 00:02:03,210
And then there's going
to be a bigger latency

56
00:02:03,210 --> 00:02:05,629
for the Mrs. first off,

57
00:02:05,629 --> 00:02:07,369
there's no W in the cache.

58
00:02:07,369 --> 00:02:10,349
That's a mess. I add
it to the cache.

59
00:02:10,349 --> 00:02:13,249
Another. Okay, that's
straight, It's there.

60
00:02:13,249 --> 00:02:16,930
That's a X not in the cache.

61
00:02:16,930 --> 00:02:19,169
Add it first As,

62
00:02:19,169 --> 00:02:23,910
then add it, then Y
not in the cache.

63
00:02:23,910 --> 00:02:25,429
I'm going to mess and then add

64
00:02:25,429 --> 00:02:29,310
it again. Y is right there.

65
00:02:29,310 --> 00:02:33,170
That's A, then Z.

66
00:02:33,170 --> 00:02:36,310
Z is not in the cache,
so it's a mess.

67
00:02:36,550 --> 00:02:38,829
I'm going to add it here.

68
00:02:38,829 --> 00:02:40,470
Now that's a problem because I

69
00:02:40,470 --> 00:02:42,270
have too many
entries in my cache.

70
00:02:42,270 --> 00:02:43,930
Can somebody just remind me?

71
00:02:43,930 --> 00:02:47,319
Maybe everybody can just
shout out, who should I ev.

72
00:02:47,319 --> 00:02:50,850
Excellent. Right,
so I'm, because

73
00:02:50,850 --> 00:02:52,010
the most recent data is on

74
00:02:52,010 --> 00:02:54,090
this side and the older
data is on this side.

75
00:02:54,090 --> 00:02:55,849
So now I'm going to have y.

76
00:02:55,849 --> 00:02:58,889
And Y is a hit, so that's good.

77
00:02:58,889 --> 00:03:00,369
And then everybody
can either nod

78
00:03:00,369 --> 00:03:02,089
their head yes, or
shake their head, no.

79
00:03:02,089 --> 00:03:04,369
Do I have to move Y?

80
00:03:05,090 --> 00:03:08,349
No, because this is
first in, first out.

81
00:03:08,349 --> 00:03:11,049
First in, first out doesn't
share when I use things,

82
00:03:11,049 --> 00:03:14,049
it just cares about
when it.in Right.

83
00:03:14,049 --> 00:03:15,830
If I was doing LRU,

84
00:03:15,830 --> 00:03:17,229
I would move it over here.

85
00:03:17,229 --> 00:03:20,650
But this isn't
LRU, this is Fifo.

86
00:03:20,650 --> 00:03:24,569
I have an X and that's
a head as well.

87
00:03:24,569 --> 00:03:25,969
Right? And I don't have to move

88
00:03:25,969 --> 00:03:27,490
my X either. So let
me tout this off.

89
00:03:27,490 --> 00:03:37,030
I have 12344/8 equals 0.5 Great.

90
00:03:37,030 --> 00:03:38,630
I was able to figure out what

91
00:03:38,630 --> 00:03:40,129
percentage of them are hits,

92
00:03:40,129 --> 00:03:42,249
and then based on some
additional information,

93
00:03:42,249 --> 00:03:44,550
I can see what the
average latency was.

94
00:03:44,550 --> 00:03:50,030
Half of the time it took
me 20 milliseconds,

95
00:03:50,030 --> 00:03:57,169
and then half of the time it
took me 0.1 milliseconds.

96
00:03:57,170 --> 00:04:00,089
Right, And what does
that equal? That will be

97
00:04:00,089 --> 00:04:05,110
10.05 milliseconds on average.

98
00:04:05,110 --> 00:04:08,229
Right? Lots of questions
I could ask you.

99
00:04:08,229 --> 00:04:10,230
I could ask which ones
are specifically hits.

100
00:04:10,230 --> 00:04:11,665
I could ask what
the hit rate is.

101
00:04:11,665 --> 00:04:13,819
I could ask how does that play

102
00:04:13,819 --> 00:04:16,419
out in terms of actual performance
at the end of the day?

103
00:04:16,419 --> 00:04:19,839
So what questions do people
have about this problem?

104
00:04:23,640 --> 00:04:28,560
All right, so let's look at
some other use cases here.

105
00:04:28,560 --> 00:04:30,140
I'm right to drove
through this one

106
00:04:30,140 --> 00:04:32,459
a little bit faster now because

107
00:04:32,459 --> 00:04:34,900
we've spent some time
on the basic idea

108
00:04:34,900 --> 00:04:37,919
of how you step through
it and trace it.

109
00:04:37,919 --> 00:04:39,440
So what I want to do now is just

110
00:04:39,440 --> 00:04:42,159
try to walk through it
quickly and then see,

111
00:04:42,760 --> 00:04:45,080
make some observations about we

112
00:04:45,080 --> 00:04:48,360
LRU is doing well
or what it's not.

113
00:04:48,720 --> 00:04:50,840
I'm got look at this,

114
00:04:50,840 --> 00:04:53,299
I see I have a
cash of size four.

115
00:04:53,299 --> 00:04:59,859
What is the pattern? It's
34567, then repeat 34567.

116
00:04:59,859 --> 00:05:03,439
So I can see that the
first five are all Mrs.

117
00:05:03,439 --> 00:05:04,980
because the first
time you access

118
00:05:04,980 --> 00:05:07,320
anything has to be a mess.

119
00:05:07,320 --> 00:05:11,159
Right. And then
whatever was least

120
00:05:11,159 --> 00:05:12,860
recently used gets
bumped out and

121
00:05:12,860 --> 00:05:15,100
whatever is most
recently used stays in.

122
00:05:15,100 --> 00:05:22,060
I guess what we'll be staying
in is 45674567, right?

123
00:05:22,060 --> 00:05:23,399
So the first half
of that's where I

124
00:05:23,399 --> 00:05:25,740
got to no hits so far.

125
00:05:25,740 --> 00:05:28,379
So now I have a three,

126
00:05:28,379 --> 00:05:31,740
which is a real shame because
I just bumped three out,

127
00:05:31,740 --> 00:05:36,000
but I guess three is a
mess. Bring it back in.

128
00:05:36,990 --> 00:05:39,930
Four? Uh. Oh, Well,

129
00:05:39,930 --> 00:05:41,730
I guess that's a miss too.

130
00:05:41,730 --> 00:05:44,110
Another shame because I
had just kicked four out.

131
00:05:44,110 --> 00:05:47,630
So I'm going to put four
here and bump this one out.

132
00:05:47,630 --> 00:05:49,450
This keeps happening to me.

133
00:05:49,450 --> 00:05:53,230
So there's a five, all right?

134
00:05:53,230 --> 00:05:57,370
I have a six. I had
just taken six out,

135
00:05:57,370 --> 00:06:01,630
but now it's back seven.
Same deal, right?

136
00:06:01,630 --> 00:06:04,290
You get the idea. It's a
repeating pattern, right?

137
00:06:04,290 --> 00:06:08,989
And my hit rate is a big
whopping zero. All right?

138
00:06:08,989 --> 00:06:11,750
Lru, when you first learn
about the policies,

139
00:06:11,750 --> 00:06:14,030
LRU feels like the
smartest one, right?

140
00:06:14,030 --> 00:06:15,669
It's like, well, it
takes into account

141
00:06:15,669 --> 00:06:18,249
that I've been using
this a lot recently.

142
00:06:18,249 --> 00:06:20,610
But this is the one big pattern

143
00:06:20,610 --> 00:06:23,190
that LRU is really bad at,

144
00:06:23,190 --> 00:06:26,409
when a program keeps
scanning the dataset

145
00:06:26,409 --> 00:06:30,369
multiple times and the dataset
is too big for the cache.

146
00:06:30,369 --> 00:06:34,269
Can we saw a use
case this semester?

147
00:06:34,269 --> 00:06:36,810
We keep scanning the same
dataset over and over again.

148
00:06:36,810 --> 00:06:38,330
Can anybody refresh my memory?

149
00:06:38,330 --> 00:06:40,430
When might we have to do that?

150
00:06:45,760 --> 00:06:52,359
Yeah, right here.
Matrix multiplication.

151
00:06:52,359 --> 00:06:53,840
Yeah, I think that
might be a case.

152
00:06:53,840 --> 00:06:55,260
I haven't thought
through enough, right?

153
00:06:55,260 --> 00:06:57,599
But yeah, we might have
to because I guess we use

154
00:06:57,599 --> 00:07:00,340
the same columns on
many different rows.

155
00:07:00,340 --> 00:07:01,580
Right. So we might
keep scanning it.

156
00:07:01,580 --> 00:07:03,799
So yeah, I think that's
true, right? Absolutely.

157
00:07:03,799 --> 00:07:05,220
Right. We didn't drove
through that. Are there

158
00:07:05,220 --> 00:07:06,960
other other examples that
people can think of?

159
00:07:06,960 --> 00:07:10,560
Yeah, right back
here. What's that?

160
00:07:10,560 --> 00:07:12,599
Maybe, I mean, maybe you have

161
00:07:12,599 --> 00:07:14,179
to keep scanning a web page.

162
00:07:14,179 --> 00:07:16,040
Yeah. Who knows?

163
00:07:16,040 --> 00:07:17,639
Maybe you do it

164
00:07:17,639 --> 00:07:19,399
and then you wait awhile
and scan it again. Yeah.

165
00:07:19,399 --> 00:07:22,680
Is there a hand up front
here? What's that?

166
00:07:22,680 --> 00:07:25,080
Yeah. Training epoch.

167
00:07:25,080 --> 00:07:26,420
That was the one that
trying that came to mind.

168
00:07:26,420 --> 00:07:27,619
I think all these
are right answers.

169
00:07:27,619 --> 00:07:29,200
But in machine learning, right,

170
00:07:29,200 --> 00:07:30,539
You can't just make one pass

171
00:07:30,539 --> 00:07:31,779
over the data and
learn everything.

172
00:07:31,779 --> 00:07:33,360
You keep looking
at the same data

173
00:07:33,360 --> 00:07:35,699
again and again and
again and again.

174
00:07:35,699 --> 00:07:37,760
If you shuffle your batches,

175
00:07:37,760 --> 00:07:39,560
maybe it's not so bad, right?

176
00:07:39,560 --> 00:07:41,000
But if you aren't shuffling

177
00:07:41,000 --> 00:07:42,120
and you have that
training epoch,

178
00:07:42,120 --> 00:07:44,359
you're gonna get into
exactly this problem for

179
00:07:44,359 --> 00:07:47,639
a very standard machine
learning access pattern, right?

180
00:07:47,639 --> 00:07:49,659
So this is a real pattern.
It happens, it's common.

181
00:07:49,659 --> 00:07:52,180
Lru is really bad at it.

182
00:07:52,180 --> 00:07:54,920
We had learned, well,

183
00:07:54,920 --> 00:07:56,479
I guess what about Fifo?

184
00:07:56,479 --> 00:07:57,719
Would Fifo be any
better at this?

185
00:07:57,719 --> 00:08:00,039
People can shake their
head. Yes or no?

186
00:08:00,039 --> 00:08:05,580
Fifo, help me here.
No, thank you.

187
00:08:05,580 --> 00:08:07,099
Fifo is just as bad, right?

188
00:08:07,099 --> 00:08:08,480
Because Fifo will
have that same thing.

189
00:08:08,480 --> 00:08:10,060
We keep kicking it out.

190
00:08:10,060 --> 00:08:12,039
The third pattern that
we had talked about

191
00:08:12,039 --> 00:08:13,820
very briefly was that we
could randomly ev something,

192
00:08:13,820 --> 00:08:15,320
when evi just choose one,

193
00:08:15,320 --> 00:08:16,740
randomly bump it out.

194
00:08:16,740 --> 00:08:19,900
That would actually be quite
a lot better here, right?

195
00:08:19,900 --> 00:08:23,779
Because, you know,
80% of our data,

196
00:08:23,779 --> 00:08:26,639
four fifths of our data
fits in the cache.

197
00:08:26,639 --> 00:08:27,899
And if we're doing it randomly,

198
00:08:27,899 --> 00:08:30,360
then kind of long term would
take some time to warm up.

199
00:08:30,360 --> 00:08:31,800
But on average, I'd
probably be getting

200
00:08:31,800 --> 00:08:33,899
about in a 80% hit
rate long term.

201
00:08:33,899 --> 00:08:36,300
So random just feels
like a stupid policy,

202
00:08:36,300 --> 00:08:37,740
but in some cases it would be

203
00:08:37,740 --> 00:08:40,060
a smart policy like LRU, right?

204
00:08:40,060 --> 00:08:43,499
So it all depends on
what your workload is.

205
00:08:43,499 --> 00:08:48,569
All right, let's take
a look at this one.

206
00:08:48,569 --> 00:08:51,069
This is actually exactly
the same problem,

207
00:08:51,069 --> 00:08:53,890
but now I have a
cache size five.

208
00:08:53,890 --> 00:08:56,489
All right, so I have 34567,

209
00:08:56,489 --> 00:08:59,190
then repeat without even
tracing through this.

210
00:08:59,190 --> 00:09:02,010
Can anybody tell me what the
hit rate is going to be?

211
00:09:02,010 --> 00:09:05,010
Yeah, right here half.

212
00:09:05,010 --> 00:09:09,969
All right, so our entire
dataset fits in memory,

213
00:09:09,969 --> 00:09:11,990
which is good. It
fits in the cache.

214
00:09:11,990 --> 00:09:13,509
But we still, even if we have,

215
00:09:13,509 --> 00:09:15,390
you know, the best
possible case,

216
00:09:15,390 --> 00:09:17,829
we have a huge, even
the biggest caches

217
00:09:17,829 --> 00:09:20,069
have to have some time
to warm up. All right?

218
00:09:20,069 --> 00:09:22,870
So it'll see those half
those items first,

219
00:09:22,870 --> 00:09:25,270
it won't be there, and
then the second pass

220
00:09:25,270 --> 00:09:26,650
through it will all be in there.

221
00:09:26,650 --> 00:09:27,929
And the longer I run, the more

222
00:09:27,929 --> 00:09:29,694
I can benefit from that cache.

223
00:09:29,694 --> 00:09:32,079
All right, cool. Do people have

224
00:09:32,079 --> 00:09:36,420
any last questions about
these cash policies?

225
00:09:37,660 --> 00:09:40,220
All right, well I
want to work through

226
00:09:40,220 --> 00:09:41,700
a programming example
because I know

227
00:09:41,700 --> 00:09:43,419
you're going to have to do
this on your project soon.

228
00:09:43,419 --> 00:09:45,499
And I think it will
help you to see some

229
00:09:45,499 --> 00:09:48,020
code read in to get a
sense of how this is done.

230
00:09:48,020 --> 00:09:49,619
And of course, I'll
post the notebooks on

231
00:09:49,619 --> 00:09:51,660
line afterwards.

232
00:09:51,660 --> 00:09:54,559
So I have some starter
code for this one.

233
00:09:54,559 --> 00:09:56,579
This was originally going to

234
00:09:56,579 --> 00:09:58,020
be lecture nine,
which was last time.

235
00:09:58,020 --> 00:09:59,419
So I'm going to copy
from down here.

236
00:09:59,419 --> 00:10:03,220
I'm sure to copy this
whole big example.

237
00:10:03,500 --> 00:10:05,679
I'm going to paste it down here.

238
00:10:05,679 --> 00:10:07,019
And there's a couple of
different things going on,

239
00:10:07,019 --> 00:10:08,819
so I'm just going
to split it up.

240
00:10:08,819 --> 00:10:11,419
So I'm going to have that
piece and then this piece down

241
00:10:11,419 --> 00:10:15,000
here. What are we doing?

242
00:10:15,000 --> 00:10:17,080
We're doing request. So some of

243
00:10:17,080 --> 00:10:18,179
you might have seen
that if you have

244
00:10:18,179 --> 00:10:19,300
more Python background,

245
00:10:19,300 --> 00:10:21,559
but that's just
downloading this web page.

246
00:10:21,559 --> 00:10:24,259
And I'm going to open this
up and see what's there.

247
00:10:24,259 --> 00:10:26,720
And it turns out what it
contains is a bunch of

248
00:10:26,720 --> 00:10:29,719
different ID's for
weather stations.

249
00:10:29,719 --> 00:10:30,779
So what we want to do

250
00:10:30,779 --> 00:10:32,420
is for one of these
weather stations,

251
00:10:32,420 --> 00:10:35,289
we want to look up the weather
weather that it's having.

252
00:10:35,289 --> 00:10:38,380
Okay? And so that's what
this is doing down here.

253
00:10:38,380 --> 00:10:39,899
We have this other URL which

254
00:10:39,899 --> 00:10:41,380
takes us to the weather data.

255
00:10:41,380 --> 00:10:43,979
And then we can put in different
names here because it's

256
00:10:43,979 --> 00:10:47,239
a format string to get that.

257
00:10:47,239 --> 00:10:49,500
All right, so what is
it doing down here?

258
00:10:49,500 --> 00:10:53,100
So first I'm checking,
was there a status code?

259
00:10:53,100 --> 00:10:54,940
Sometimes when you're fetching
things from a website,

260
00:10:54,940 --> 00:10:57,059
the server responds
and says four oh four,

261
00:10:57,059 --> 00:10:59,899
I don't have it for me.

262
00:10:59,899 --> 00:11:01,979
I would rather crash
than try to parse out

263
00:11:01,979 --> 00:11:04,440
that error page because it
doesn't have the data I want.

264
00:11:04,440 --> 00:11:06,500
So if we get past this line,

265
00:11:06,500 --> 00:11:08,119
which sometimes
raises an exception,

266
00:11:08,119 --> 00:11:10,520
I was able to successfully
grab the page

267
00:11:10,520 --> 00:11:13,740
and it has text
which I can analyze.

268
00:11:13,740 --> 00:11:15,200
And so I'm splitting that up by

269
00:11:15,200 --> 00:11:17,645
the new line character to
get a bunch of stations.

270
00:11:17,645 --> 00:11:19,889
And then we're randomly

271
00:11:19,889 --> 00:11:23,429
picking ten different
stations. Random sample.

272
00:11:23,429 --> 00:11:26,269
And then from those
stations we're

273
00:11:26,269 --> 00:11:29,110
sampling from those 10100 times.

274
00:11:29,110 --> 00:11:31,409
Right? So those ten might, well,

275
00:11:31,409 --> 00:11:32,630
they'll definitely
have a bunch of

276
00:11:32,630 --> 00:11:34,729
repeats on them to
get to 100, right?

277
00:11:34,729 --> 00:11:35,790
So if I look at it down here,

278
00:11:35,790 --> 00:11:37,769
I have my stations here,

279
00:11:37,769 --> 00:11:39,949
just ten and then my work

280
00:11:39,949 --> 00:11:44,450
load right there will be some
repeats down here, I guess.

281
00:11:44,450 --> 00:11:47,369
Like this one repeats with two.

282
00:11:47,369 --> 00:11:49,870
This one repeats with
this one, right?

283
00:11:49,870 --> 00:11:51,849
Repeats. That's fairly common

284
00:11:51,849 --> 00:11:55,010
because I put some
weights here, right?

285
00:11:55,010 --> 00:11:56,750
Of these ten stations,

286
00:11:56,750 --> 00:11:58,630
one of them is going to
appear 30% of the time,

287
00:11:58,630 --> 00:12:00,270
the other one will
be 20% of the time.

288
00:12:00,270 --> 00:12:02,189
And then the rest all
have equal weight.

289
00:12:02,189 --> 00:12:03,829
So I'm just trying to
slice this so it's

290
00:12:03,829 --> 00:12:07,950
handy so we can see
it there. All right.

291
00:12:07,950 --> 00:12:09,930
Now, if you were
writing a real program,

292
00:12:09,930 --> 00:12:12,350
it would probably
have a genuine reason

293
00:12:12,350 --> 00:12:13,990
to go be downloading
these pages.

294
00:12:13,990 --> 00:12:15,429
And I don't want to get into
the complexity of that.

295
00:12:15,429 --> 00:12:16,810
So I'm just trying to assume

296
00:12:16,810 --> 00:12:18,409
that there's some program and it

297
00:12:18,409 --> 00:12:21,970
needs to access these weather
stations in this order.

298
00:12:21,970 --> 00:12:23,770
And what I want to
do is see how we can

299
00:12:23,770 --> 00:12:25,510
do it efficiently, right?

300
00:12:25,510 --> 00:12:26,449
You see it's repeatedly

301
00:12:26,449 --> 00:12:27,910
downloading a lot
of the same things.

302
00:12:27,910 --> 00:12:29,250
Can we cache them so we

303
00:12:29,250 --> 00:12:31,350
don't have to do
it more than once?

304
00:12:31,350 --> 00:12:32,930
All right, so let

305
00:12:32,930 --> 00:12:34,370
me just come down here
and see how this works.

306
00:12:34,370 --> 00:12:36,969
I'm going to grab the
first weather station.

307
00:12:37,240 --> 00:12:40,479
I can just paste
that right here.

308
00:12:40,479 --> 00:12:43,099
When I do that, I
should be able to get

309
00:12:43,099 --> 00:12:44,259
a data frame and maybe just

310
00:12:44,259 --> 00:12:46,419
look at the first
three rows of it.

311
00:12:46,419 --> 00:12:49,240
Pandas has a read CSV that can

312
00:12:49,240 --> 00:12:51,600
fetch these things
for us, right?

313
00:12:51,600 --> 00:12:52,780
So I was able to
grab some weather

314
00:12:52,780 --> 00:12:53,960
there and I was just like, oh,

315
00:12:53,960 --> 00:12:55,479
okay, I have some
kind of warning,

316
00:12:55,479 --> 00:12:57,739
I won't worry too much about it.

317
00:12:57,739 --> 00:12:59,959
Great. So I was able to do that.

318
00:12:59,959 --> 00:13:01,539
Maybe there's something
weird about that file.

319
00:13:01,539 --> 00:13:03,960
I'm just trying to grab
a different set set

320
00:13:03,960 --> 00:13:05,799
of them so we aren't
dealing with that.

321
00:13:05,799 --> 00:13:08,439
Is that all of them? They
all have that. That's weird.

322
00:13:08,439 --> 00:13:10,320
I don't think that was
popping up this morning.

323
00:13:10,320 --> 00:13:11,700
Anyway. Not a problem, right?

324
00:13:11,700 --> 00:13:14,440
That we can have an error,
they're not a big deal.

325
00:13:15,000 --> 00:13:17,919
What I want to do
is that instead of

326
00:13:17,919 --> 00:13:19,800
having whoever is doing

327
00:13:19,800 --> 00:13:21,620
this work directly
called read CSV,

328
00:13:21,620 --> 00:13:23,720
I want a function that can take

329
00:13:23,720 --> 00:13:26,199
a station name and then
give them that data frame.

330
00:13:26,199 --> 00:13:28,120
And they won't even have
to think about caching,

331
00:13:28,120 --> 00:13:29,580
but my function will
do that for them

332
00:13:29,580 --> 00:13:31,460
if they call it with
the same station name.

333
00:13:31,460 --> 00:13:33,659
It might be faster
the next time, right?

334
00:13:33,659 --> 00:13:34,120
So let's do that.

335
00:13:34,120 --> 00:13:36,259
I'm going to write a
function called it station.

336
00:13:36,259 --> 00:13:39,160
And that's going to
take a station name.

337
00:13:39,160 --> 00:13:42,119
And then what I'll do
is I'll just copy this.

338
00:13:42,119 --> 00:13:44,040
To get my data frame,

339
00:13:44,040 --> 00:13:46,280
I will return it down here.

340
00:13:46,280 --> 00:13:48,500
I'm going to get that data
frame and I'm going to return

341
00:13:48,500 --> 00:13:50,879
it. Let's just try this.

342
00:13:50,879 --> 00:13:52,419
I'm going to say it station,

343
00:13:52,419 --> 00:13:55,200
and then I'm going to
try this one right here.

344
00:13:55,760 --> 00:14:01,399
All right? I'm going
to do that again.

345
00:14:01,399 --> 00:14:04,259
I'm just trying to figure out
why it started doing this.

346
00:14:04,259 --> 00:14:07,800
Maybe if I say this little
memory thing, it'll be fine.

347
00:14:07,800 --> 00:14:09,840
Will it be quiet
then? Okay, great.

348
00:14:09,840 --> 00:14:12,100
So I'm going to do that and
then it won't complain.

349
00:14:12,100 --> 00:14:14,299
And we don't tend too many
details about that right now.

350
00:14:14,299 --> 00:14:16,040
It might be something
we come back to later.

351
00:14:16,040 --> 00:14:19,220
Right? But I can see, okay,
you grab that station, great.

352
00:14:19,220 --> 00:14:20,720
Now what I can do is I can add

353
00:14:20,720 --> 00:14:23,260
some caching capabilities
to this function,

354
00:14:23,260 --> 00:14:25,140
and the user won't have
to worry about it.

355
00:14:25,140 --> 00:14:25,280
Right?

356
00:14:25,280 --> 00:14:27,599
They'll call the function the
same way they always have.

357
00:14:27,599 --> 00:14:29,120
The way I often like to do

358
00:14:29,120 --> 00:14:32,259
a cache is to create
a dictionary.

359
00:14:32,259 --> 00:14:34,600
May be called cash, right?

360
00:14:34,600 --> 00:14:36,580
Say cash going to
be a dictionary.

361
00:14:36,580 --> 00:14:38,880
And one of the most useful
comments I think when

362
00:14:38,880 --> 00:14:39,959
you're creating a
dictionary is say

363
00:14:39,959 --> 00:14:41,219
what the keys and
values are going.

364
00:14:41,219 --> 00:14:44,239
Say the keys are
station name and

365
00:14:44,239 --> 00:14:51,240
the value is drawing to B
data frame for that station.

366
00:14:51,240 --> 00:14:53,520
All right, so what
I should do is

367
00:14:53,520 --> 00:14:56,020
that after I grab

368
00:14:56,020 --> 00:14:57,520
the data frame, I
should put it in there.

369
00:14:57,520 --> 00:15:00,279
I should say the cache of

370
00:15:00,279 --> 00:15:02,239
the station should equal

371
00:15:02,239 --> 00:15:04,540
that data frame. I
might add it there.

372
00:15:04,540 --> 00:15:09,380
If I run this, then if
I look at my cache,

373
00:15:09,380 --> 00:15:11,500
I can see grade, It has this key

374
00:15:11,500 --> 00:15:13,780
here and an associated
data frame with it.

375
00:15:13,780 --> 00:15:15,840
So I remembered it somewhere
if somebody wants to

376
00:15:15,840 --> 00:15:18,159
go get it again. All right.

377
00:15:18,159 --> 00:15:20,480
So that's good.
Right now though,

378
00:15:20,480 --> 00:15:22,080
I'm not actually using
my cash anything,

379
00:15:22,080 --> 00:15:24,039
putting something in there,
but not pulling anything out.

380
00:15:24,039 --> 00:15:25,940
And so I should have
a big F statement up

381
00:15:25,940 --> 00:15:27,860
here that can handle two cases.

382
00:15:27,860 --> 00:15:32,539
Right, So if this station
is in the cache, then what?

383
00:15:32,539 --> 00:15:36,360
Then I guess I have a
hit, which is cool.

384
00:15:36,800 --> 00:15:39,580
Otherwise what if it's

385
00:15:39,580 --> 00:15:41,239
not in the cache?
Then it's a mess.

386
00:15:41,239 --> 00:15:43,380
So those are the two
scenarios, right,

387
00:15:43,380 --> 00:15:45,480
And all this code
I wrote so far,

388
00:15:45,480 --> 00:15:47,019
it's actually doing
the slow work

389
00:15:47,019 --> 00:15:48,759
of going out to the
Internet and grabbing that.

390
00:15:48,759 --> 00:15:51,159
So this is the kind
of code that I would

391
00:15:51,159 --> 00:15:53,800
put on this miss path.

392
00:15:53,800 --> 00:15:55,779
All right, so I'm going
to put this down here,

393
00:15:55,779 --> 00:15:57,520
so I missed in my cache,

394
00:15:57,520 --> 00:16:01,604
I'm going to grab that data
frame and then return it.

395
00:16:01,604 --> 00:16:04,609
All right, maybe
I'm trying to put

396
00:16:04,609 --> 00:16:05,890
some print statements
up here so I can

397
00:16:05,890 --> 00:16:07,690
see what's happening a
little bit more easily.

398
00:16:07,690 --> 00:16:10,030
And then up here I'm
trying print head.

399
00:16:10,030 --> 00:16:12,049
All right, so now I figure

400
00:16:12,049 --> 00:16:13,270
out what I want to
do in this case.

401
00:16:13,270 --> 00:16:15,490
All right, so one of
the things I could do

402
00:16:15,490 --> 00:16:17,770
is I could just return cache

403
00:16:17,770 --> 00:16:20,350
of station because I

404
00:16:20,350 --> 00:16:22,590
know that that's the data
frame that I'm looking for.

405
00:16:22,590 --> 00:16:24,330
One thing that I think will make

406
00:16:24,330 --> 00:16:26,009
our code easier in general,

407
00:16:26,009 --> 00:16:27,589
and I think is a
good practice when

408
00:16:27,589 --> 00:16:29,369
it's not too difficult is

409
00:16:29,369 --> 00:16:32,990
to just have one exit point
from your function, right?

410
00:16:32,990 --> 00:16:35,210
So if I only have one
exit point down here,

411
00:16:35,210 --> 00:16:37,429
then the code just just
a little easier to read.

412
00:16:37,429 --> 00:16:39,090
And if I later come
along and I want to

413
00:16:39,090 --> 00:16:40,950
measure how long the
function takes to run,

414
00:16:40,950 --> 00:16:42,989
it's easier for me to
do those measurements.

415
00:16:42,989 --> 00:16:44,389
All right, so I have this.

416
00:16:44,389 --> 00:16:48,349
And let's just give it a shot,
right? So I have this one.

417
00:16:48,349 --> 00:16:51,690
Let's try it again a few times.

418
00:16:51,690 --> 00:16:54,429
The first time it was a
miss. That was kind of slow.

419
00:16:54,429 --> 00:16:57,010
And then it was pretty
fast. It got these hits.

420
00:16:57,010 --> 00:16:58,530
All right, So I have a cache,

421
00:16:58,530 --> 00:17:00,830
I can add things to it, I
can make my code faster.

422
00:17:00,830 --> 00:17:02,750
And if you have lots of memory,

423
00:17:02,750 --> 00:17:04,829
something like this, a
little function like this

424
00:17:04,829 --> 00:17:06,810
might save you a
lot of time, right?

425
00:17:06,810 --> 00:17:08,549
And you might not even have
to worry about evicting

426
00:17:08,549 --> 00:17:10,370
because you have lots
of resources, right?

427
00:17:10,370 --> 00:17:13,110
So people write toward
like this all the time.

428
00:17:13,110 --> 00:17:15,129
All right. Any question?

429
00:17:15,129 --> 00:17:16,430
I guess there's like maybe

430
00:17:16,430 --> 00:17:17,650
some Python stuff
is new to people.

431
00:17:17,650 --> 00:17:19,509
I know some people are coming
from a Java background.

432
00:17:19,509 --> 00:17:20,869
And any questions
about this code

433
00:17:20,869 --> 00:17:23,370
before I think about eviction?

434
00:17:29,140 --> 00:17:35,040
All right, cool. When
do I have to ev?

435
00:17:35,040 --> 00:17:37,820
Sometimes I have
to ev Down here,

436
00:17:37,820 --> 00:17:41,739
if the length of the cash
is bigger than something,

437
00:17:41,739 --> 00:17:43,780
then I have to ev, right?

438
00:17:43,780 --> 00:17:46,119
Because I don't
have enough space.

439
00:17:46,119 --> 00:17:49,600
Okay. Well, how big is my cash?

440
00:17:49,600 --> 00:17:51,419
I think for now I'm just
going to say that I have

441
00:17:51,419 --> 00:17:53,859
some cash size that's
fixed up here.

442
00:17:53,859 --> 00:17:57,300
I'll say that's like
five to say cash.

443
00:17:57,540 --> 00:17:59,979
In a realistic scenario,
you'd be kind of

444
00:17:59,979 --> 00:18:01,499
thinking about how
big these data frames

445
00:18:01,499 --> 00:18:02,619
are and how much memory you

446
00:18:02,619 --> 00:18:04,680
have and evicting accordingly.

447
00:18:04,680 --> 00:18:06,360
Right? But we'll just
say it's a fixed size.

448
00:18:06,360 --> 00:18:11,259
For now, I have that
and then I have to,

449
00:18:11,259 --> 00:18:13,300
how do I ev, maybe I'll make

450
00:18:13,300 --> 00:18:14,800
this comment up here. All right.

451
00:18:14,800 --> 00:18:18,399
So I'll say, should we
ev if I want to evict,

452
00:18:18,399 --> 00:18:23,879
I have to find a
victim Right, somehow.

453
00:18:23,879 --> 00:18:25,319
And then what do I have to do?

454
00:18:25,319 --> 00:18:26,480
I have to remove
it from the cash,

455
00:18:26,480 --> 00:18:29,899
let me say cash dot pop victim.

456
00:18:29,899 --> 00:18:32,560
Right. This is a key
in that dictionary,

457
00:18:32,560 --> 00:18:35,620
is trying to remove the value
associated with that key.

458
00:18:35,620 --> 00:18:37,980
All right, so how do
I do this up here?

459
00:18:37,980 --> 00:18:42,459
Well, what I need to do is
I need to have some sense

460
00:18:42,459 --> 00:18:45,739
of when this item was actually

461
00:18:45,739 --> 00:18:48,909
added to my dictionary, right?

462
00:18:48,909 --> 00:18:51,209
Python dictionaries actually
keep track of that.

463
00:18:51,209 --> 00:18:53,470
Now they can show you
the insertion order.

464
00:18:53,470 --> 00:18:55,189
But for simplicity
I'm just trying to

465
00:18:55,189 --> 00:18:57,369
assume that I need a separate
data structure for that.

466
00:18:57,369 --> 00:18:59,669
So what I'll do up
here is I'll say that

467
00:18:59,669 --> 00:19:02,690
I have an evict order up here.

468
00:19:02,690 --> 00:19:07,169
And I'll make a comment
here that start

469
00:19:07,169 --> 00:19:12,149
of list contains
items to be evicted.

470
00:19:12,149 --> 00:19:15,070
End of list is freshest.

471
00:19:15,070 --> 00:19:19,689
All right? I have that.
What do I want to do?

472
00:19:19,689 --> 00:19:22,469
Well, I want to take the
very first item off of here,

473
00:19:22,469 --> 00:19:25,330
so I'm going to say
evict order pop.

474
00:19:25,330 --> 00:19:27,030
And in this case I
have index zero.

475
00:19:27,030 --> 00:19:29,450
All right, so this is
pop from the front.

476
00:19:29,450 --> 00:19:31,829
I just trying to make
a little note here.

477
00:19:31,829 --> 00:19:34,389
I'm going to say to do,

478
00:19:35,430 --> 00:19:42,109
use a faster data
structure for evict order.

479
00:19:42,270 --> 00:19:48,650
That is not order in
for pop zero, right?

480
00:19:48,650 --> 00:19:50,210
Whenever I have a Python list

481
00:19:50,210 --> 00:19:52,089
and I pop something
from the beginning,

482
00:19:52,089 --> 00:19:54,550
every other item has to
shift to the left, right?

483
00:19:54,550 --> 00:19:56,930
Because we need to have a
new value at item zero.

484
00:19:56,930 --> 00:19:58,770
I'm not trying to worry
about that much for now.

485
00:19:58,770 --> 00:20:01,849
Right. And honestly, when I
have a short list like this,

486
00:20:01,849 --> 00:20:05,029
shifting everything over is
incredibly fast compared

487
00:20:05,029 --> 00:20:07,870
to downloading something
from a web page.

488
00:20:07,870 --> 00:20:09,349
Right. So I think that's fine.

489
00:20:09,349 --> 00:20:10,610
Right. All right.

490
00:20:10,610 --> 00:20:13,770
So I think we're in
pretty good shape, right?

491
00:20:13,770 --> 00:20:16,730
We have our hit case,
we have our mis case.

492
00:20:17,250 --> 00:20:21,009
And what policy can

493
00:20:21,009 --> 00:20:22,369
anybody help me out
with what policy

494
00:20:22,369 --> 00:20:24,409
I've implemented so far?

495
00:20:25,930 --> 00:20:28,849
This is yeah, right here,

496
00:20:28,849 --> 00:20:30,789
it's close to an LRU.

497
00:20:30,789 --> 00:20:34,749
I'm definitely kind of

498
00:20:34,749 --> 00:20:35,910
kicking out the data that's

499
00:20:35,910 --> 00:20:37,130
been there in there for a while.

500
00:20:37,130 --> 00:20:39,990
But Yeah, go ahead.
First in, first out.

501
00:20:39,990 --> 00:20:42,069
It's first in, first out
and they're very similar.

502
00:20:42,069 --> 00:20:43,229
Right? So the difference is, is

503
00:20:43,229 --> 00:20:45,329
that right here if
you're trying to

504
00:20:45,329 --> 00:20:47,109
distinguish LRU and fo you

505
00:20:47,109 --> 00:20:49,349
look at when somebody
hits in the cache,

506
00:20:49,349 --> 00:20:50,730
do they have to move it around?

507
00:20:50,730 --> 00:20:54,049
And right now I don't
do it. Right? So this

508
00:20:54,049 --> 00:20:56,489
is a fo policy.

509
00:20:56,489 --> 00:20:59,150
All right, so what
I want to do now,

510
00:20:59,150 --> 00:21:02,970
I want to loop over all
the stations, right?

511
00:21:02,970 --> 00:21:05,249
So I'm say for station
in my workload,

512
00:21:05,249 --> 00:21:08,109
I'm going to print off what
that station is and I have

513
00:21:08,109 --> 00:21:11,589
a bunch of them. That's cool.

514
00:21:11,589 --> 00:21:14,349
What I want to do is I want
to get a data frame for it.

515
00:21:14,349 --> 00:21:17,569
Right? I say data frame,

516
00:21:19,890 --> 00:21:25,289
it will be for that station.

517
00:21:25,289 --> 00:21:27,309
I'm going to do that.

518
00:21:27,309 --> 00:21:33,230
I should get a bunch
of hits or Mrs. maybe

519
00:21:33,230 --> 00:21:35,789
what I want to show is that
after each of these what

520
00:21:35,789 --> 00:21:38,969
I'll print is what
station it was.

521
00:21:38,969 --> 00:21:42,429
And then I want to show what's
inside of my evict order.

522
00:21:42,429 --> 00:21:44,450
Right? That will kind
of give me insight

523
00:21:44,450 --> 00:21:46,549
into the state of the cache.

524
00:21:46,549 --> 00:21:50,769
All right, so I have a problem,

525
00:21:50,769 --> 00:21:55,129
which is what I think I
meant to add this up here,

526
00:21:55,129 --> 00:21:57,429
but that shouldn't be
breaking things that badly.

527
00:21:57,429 --> 00:22:01,630
Right. Okay. So I think
I missed one thing,

528
00:22:01,630 --> 00:22:06,309
which is that when we
add it into the cache,

529
00:22:06,309 --> 00:22:09,170
I also need to update
my evict order.

530
00:22:09,170 --> 00:22:12,609
Right, So my evict order
should append that station.

531
00:22:12,609 --> 00:22:14,310
Right, so I added
and then I also

532
00:22:14,310 --> 00:22:16,190
have a sense a pend
goes to the end,

533
00:22:16,190 --> 00:22:18,349
so that means this is
the freshest station.

534
00:22:18,349 --> 00:22:19,489
Right, so I do.

535
00:22:19,489 --> 00:22:22,069
Now I can see that things
keep getting added to

536
00:22:22,069 --> 00:22:25,310
the cache until
it's of size five.

537
00:22:25,310 --> 00:22:28,210
Right, in this case,

538
00:22:28,210 --> 00:22:30,510
right, I was hitting
in the cache, right?

539
00:22:30,510 --> 00:22:33,770
So this one hit in the
cache is right there.

540
00:22:33,770 --> 00:22:36,190
And then what about, when

541
00:22:36,190 --> 00:22:38,029
do I actually have
to change the cache?

542
00:22:38,029 --> 00:22:40,950
Oh, here we actually
get to size five.

543
00:22:40,950 --> 00:22:44,029
Okay, so I think that let
me find a miss down here.

544
00:22:44,029 --> 00:22:45,310
Okay, so this one
is where it gets

545
00:22:45,310 --> 00:22:47,089
a little interesting, right?

546
00:22:47,089 --> 00:22:48,690
I was accessing this one,

547
00:22:48,690 --> 00:22:50,709
it was not in the cache.

548
00:22:50,709 --> 00:22:52,369
So what do we have to do?

549
00:22:52,369 --> 00:22:54,930
We had to bump this
one out, right?

550
00:22:54,930 --> 00:22:57,750
We did, we missed, and that
one got evicted, right?

551
00:22:57,750 --> 00:22:59,869
So it was different.
And then what happened?

552
00:22:59,869 --> 00:23:05,099
Four. These four all
shifted Laugh to be the

553
00:23:05,099 --> 00:23:10,499
four to make room for this
one at the end, right?

554
00:23:10,499 --> 00:23:12,340
You can walk through
and you can see,

555
00:23:12,340 --> 00:23:16,560
is it doing the
correct thing, right?

556
00:23:16,560 --> 00:23:19,960
Let me come up here and I'm
going to simplify it a bit.

557
00:23:19,960 --> 00:23:25,039
One of the things
I want to do, I

558
00:23:25,039 --> 00:23:26,240
want to see all
this on one line.

559
00:23:26,240 --> 00:23:30,019
I say, I'll say n

560
00:23:30,019 --> 00:23:34,819
equals that way it
won't print a new line.

561
00:23:34,819 --> 00:23:36,000
After each of these, I can see

562
00:23:36,000 --> 00:23:38,700
a little bit more C on
one line As it's running,

563
00:23:38,700 --> 00:23:42,200
we're getting a bunch of
hits and Mrs. All right.

564
00:23:42,200 --> 00:23:46,839
What questions do people
have about our cash so far?

565
00:23:47,280 --> 00:23:52,120
I think it's a complete
working bio cash.

566
00:23:54,040 --> 00:23:58,620
All right. Cool.
When we have cashes,

567
00:23:58,620 --> 00:23:59,779
we want to have some way to

568
00:23:59,779 --> 00:24:02,080
evaluate how well they're doing.

569
00:24:02,080 --> 00:24:03,879
Some statistics I'm
really interested

570
00:24:03,879 --> 00:24:06,040
in is like how often
do I hit in the cash?

571
00:24:06,040 --> 00:24:09,120
And also what is
my average latency

572
00:24:09,120 --> 00:24:12,639
'my add some variables
for that first stats.

573
00:24:12,639 --> 00:24:15,399
One of the stats will
be, do I have hits?

574
00:24:15,399 --> 00:24:21,639
This will be true as a
hit and false is a miss.

575
00:24:21,639 --> 00:24:24,379
And then I'm going to
have some latencies

576
00:24:24,379 --> 00:24:28,540
here like that, right?

577
00:24:28,540 --> 00:24:30,999
This is in milliseconds.

578
00:24:31,160 --> 00:24:35,159
What I want to do in each
scenario is I have to

579
00:24:35,159 --> 00:24:38,220
update these when I'm up
here. Then I had a hit.

580
00:24:38,220 --> 00:24:41,919
I may say hit pen, true.

581
00:24:42,000 --> 00:24:45,460
Maybe I'll just do that right
right underneath my print,

582
00:24:45,460 --> 00:24:47,540
so it's in the same
place in each of them.

583
00:24:47,540 --> 00:24:50,300
Then down here, I
know it's a mess.

584
00:24:50,300 --> 00:24:51,780
My pen false.

585
00:24:51,780 --> 00:24:54,339
So I'm going to get
some stats like that.

586
00:24:54,339 --> 00:24:58,019
Then for the latencies, I
want to do some timing.

587
00:24:58,019 --> 00:24:59,580
If I want to do some timing,

588
00:24:59,580 --> 00:25:04,410
I have to import, whoa,
what happened there?

589
00:25:04,410 --> 00:25:07,210
I have to import time.

590
00:25:07,210 --> 00:25:09,890
If I want to time
this whole thing,

591
00:25:09,890 --> 00:25:14,249
I can do a start time
up here, down here.

592
00:25:14,249 --> 00:25:16,050
I can end time,

593
00:25:16,050 --> 00:25:19,390
I can say n equals time time.

594
00:25:19,390 --> 00:25:21,510
Then we'll tell me how
many seconds since

595
00:25:21,510 --> 00:25:24,510
1970 or something like that
I mentioned earlier, right?

596
00:25:24,510 --> 00:25:26,449
I'd like to have just like one
it point for my functions,

597
00:25:26,449 --> 00:25:27,549
the data frame that makes it

598
00:25:27,549 --> 00:25:28,890
really easy to
come along and add

599
00:25:28,890 --> 00:25:31,989
this timing information
after the fact.

600
00:25:31,989 --> 00:25:34,089
All right, so I think
that the number of

601
00:25:34,089 --> 00:25:37,769
milliseconds is minus start.
That'll be in seconds.

602
00:25:37,769 --> 00:25:39,809
I should multiply that by

603
00:25:39,809 --> 00:25:43,630
1,000 and then I can
append it to my stats.

604
00:25:43,630 --> 00:25:46,469
Right, I think you

605
00:25:46,469 --> 00:25:48,129
are all going to be doing
this on the project,

606
00:25:48,129 --> 00:25:50,969
but you do have a multi
threaded thing going on,

607
00:25:50,969 --> 00:25:52,189
so you have to do some locking

608
00:25:52,189 --> 00:25:53,829
when you're collecting
these stats.

609
00:25:53,829 --> 00:25:57,490
All right, so I'm going to
do that and run this again,

610
00:25:57,490 --> 00:25:59,089
and then I should be able to

611
00:25:59,089 --> 00:26:01,369
get a bunch of stats out of it.

612
00:26:02,330 --> 00:26:04,649
All right, cool.
So I've collected

613
00:26:04,649 --> 00:26:06,970
a bunch of information so
I can look at my hits.

614
00:26:06,970 --> 00:26:08,949
If I sum these up,

615
00:26:08,949 --> 00:26:12,190
it will treat a true like
a one false like a zero.

616
00:26:12,190 --> 00:26:19,549
So that will tell me I had 57
hits, however many, right?

617
00:26:19,549 --> 00:26:23,230
So I have a 57% hit ratio.

618
00:26:23,230 --> 00:26:25,989
What about the average
latency actually?

619
00:26:25,989 --> 00:26:28,810
Right? The sum of the
latencies divided by

620
00:26:28,810 --> 00:26:32,190
the length of the latencies
is the average latency.

621
00:26:32,190 --> 00:26:33,290
Oh, quite a bit

622
00:26:33,290 --> 00:26:35,210
faster in the morning,
actually. That's interesting.

623
00:26:35,210 --> 00:26:37,249
All right, so I can
get these stats and

624
00:26:37,249 --> 00:26:39,690
then tell you how
the cash is doing.

625
00:26:39,690 --> 00:26:42,850
That would also let me do
things like say like if I made

626
00:26:42,850 --> 00:26:47,349
the cash size three
instead of size two,

627
00:26:47,349 --> 00:26:48,689
all right, let's
try it again and

628
00:26:48,689 --> 00:26:50,549
see What I think will happen is

629
00:26:50,549 --> 00:26:54,069
that hit rate
should down, right.

630
00:26:54,069 --> 00:26:55,869
Smaller cash, fewer hits.

631
00:26:55,869 --> 00:26:57,449
And as a result, like

632
00:26:57,449 --> 00:26:59,610
my latency should draw
up, is that true?

633
00:26:59,610 --> 00:27:01,670
Okay, my hit rate went down.

634
00:27:01,670 --> 00:27:05,420
My latency went up not horribly.

635
00:27:05,420 --> 00:27:07,659
And that's because
with this cache,

636
00:27:07,659 --> 00:27:08,979
I was working with
data where there are

637
00:27:08,979 --> 00:27:10,959
two popular items, Right?

638
00:27:10,959 --> 00:27:13,359
So if I went like

639
00:27:13,359 --> 00:27:14,579
below that size of how

640
00:27:14,579 --> 00:27:16,100
many are popular,
I'd have a problem.

641
00:27:16,100 --> 00:27:18,559
But there's probably diminishing
returns after I add more

642
00:27:18,559 --> 00:27:21,679
and more. All right.

643
00:27:21,679 --> 00:27:23,720
So this was a five foot cash.

644
00:27:23,720 --> 00:27:25,319
And do people have any questions

645
00:27:25,319 --> 00:27:27,239
about how to write
toad like that?

646
00:27:27,239 --> 00:27:31,900
Oh, all right.

647
00:27:31,900 --> 00:27:35,559
So what I want to do now is
I want to copy all of this

648
00:27:35,559 --> 00:27:38,379
and make a very small
change that's trying to

649
00:27:38,379 --> 00:27:40,800
turn it into an LRU, right?

650
00:27:40,800 --> 00:27:45,259
So LRU and this is
exactly the same.

651
00:27:46,660 --> 00:27:52,360
Except for the case, right?

652
00:27:52,360 --> 00:27:53,899
I have to make some changes in

653
00:27:53,899 --> 00:28:00,440
here and I have to make a
change to the evict order.

654
00:28:00,440 --> 00:28:02,380
Right? With Fifo, we don't

655
00:28:02,380 --> 00:28:04,259
really care if
somebody is using it.

656
00:28:04,259 --> 00:28:06,779
We just care about when
it got added with LRU.

657
00:28:06,779 --> 00:28:08,280
We're actually seeing
when it's used,

658
00:28:08,280 --> 00:28:10,659
when did somebody
actually look it up?

659
00:28:10,659 --> 00:28:13,179
What we'll have to do down
here is we'll have to

660
00:28:13,179 --> 00:28:20,439
say I have to remove an item.

661
00:28:20,439 --> 00:28:23,040
What I'm going to do is I'm
going to remove that station.

662
00:28:23,040 --> 00:28:23,280
Right?

663
00:28:23,280 --> 00:28:25,640
So I might be somewhere in
the middle of that list.

664
00:28:25,640 --> 00:28:29,439
Then I'm going to
pend it to the end.

665
00:28:29,439 --> 00:28:31,239
Right? So however fresh it was,

666
00:28:31,239 --> 00:28:32,499
maybe kind of like, you know,

667
00:28:32,499 --> 00:28:34,299
average freshness
somewhere in the middle.

668
00:28:34,299 --> 00:28:36,220
Pulling it out of the middle,
adding it to the end.

669
00:28:36,220 --> 00:28:38,219
This is the most fresh
data that should

670
00:28:38,219 --> 00:28:40,480
be like the last
thing to be evicted.

671
00:28:40,480 --> 00:28:43,700
And so now we can do an
interesting experiment,

672
00:28:43,700 --> 00:28:45,600
and we can run all
of this again.

673
00:28:45,600 --> 00:28:47,739
And then we can compare it.

674
00:28:47,739 --> 00:28:51,520
We can see which of
these caches is better,

675
00:28:51,520 --> 00:28:54,560
what policy is better
for us, right?

676
00:28:54,560 --> 00:28:57,800
So that's 47% hit ratio.

677
00:28:57,800 --> 00:28:59,259
So LRU seems like

678
00:28:59,259 --> 00:29:00,839
it's doing a little
bit better than Fifo.

679
00:29:00,839 --> 00:29:02,559
It's kind of a smarter
policy, right?

680
00:29:02,559 --> 00:29:03,919
It knows that there
are somebody that are

681
00:29:03,919 --> 00:29:05,960
popular that get
access more often.

682
00:29:05,960 --> 00:29:08,719
And we also have
lower latency, right?

683
00:29:08,719 --> 00:29:10,640
So it's not always true.

684
00:29:10,640 --> 00:29:12,380
Lru is often better than Fifo.

685
00:29:12,380 --> 00:29:14,460
But in this case, I can
actually back that up.

686
00:29:14,460 --> 00:29:16,239
You might do an experiment
and see otherwise.

687
00:29:16,239 --> 00:29:18,120
But then you can say,
like for this work flow,

688
00:29:18,120 --> 00:29:20,779
this is the kind of cash
policy I want to have.

689
00:29:20,779 --> 00:29:22,379
Alright? So I'm
trying to her up here

690
00:29:22,379 --> 00:29:24,939
again to show these
small changes

691
00:29:24,939 --> 00:29:26,679
I made and I think you're
going to be doing LRU and

692
00:29:26,679 --> 00:29:29,159
the sweet change at the
last minute on the project,

693
00:29:29,159 --> 00:29:32,519
or you're going to have to
implement an L LRU cache,

694
00:29:32,519 --> 00:29:36,020
a multi threaded LRU cache
to make it more interesting.

695
00:29:36,020 --> 00:29:37,799
Yeah, so what
questions do people

696
00:29:37,799 --> 00:29:40,540
have before you go off
and do it on your own?

697
00:29:40,540 --> 00:29:42,820
All right, cool.

698
00:29:42,820 --> 00:29:44,459
So I'm going to head over here,

699
00:29:44,459 --> 00:29:46,815
I want to do some slides

700
00:29:46,815 --> 00:29:50,409
and I'm going to start
talking about Pero.

701
00:29:50,570 --> 00:29:54,729
Pero is going to help us
make more effective uses

702
00:29:54,729 --> 00:29:57,289
of both the CPU cache

703
00:29:57,289 --> 00:29:58,409
and the caching that's happening

704
00:29:58,409 --> 00:30:00,589
inside of the operating system.

705
00:30:00,589 --> 00:30:03,649
All right, so a little bit
of background here, right?

706
00:30:03,649 --> 00:30:05,190
We want to start
writing more cash

707
00:30:05,190 --> 00:30:07,369
friendly co and most of
us will be about Piero.

708
00:30:07,369 --> 00:30:09,490
I'm going to show an
example of Pytorch.

709
00:30:09,490 --> 00:30:14,189
Again, to get good use of the
operating system caching,

710
00:30:14,189 --> 00:30:16,569
we have to learn about something
called memory mapping.

711
00:30:16,569 --> 00:30:18,529
Pero definitely isn't
the only system

712
00:30:18,529 --> 00:30:19,969
that can do memory mappings,

713
00:30:19,969 --> 00:30:22,129
but it makes for a nice example.

714
00:30:22,129 --> 00:30:24,089
Then for some data,

715
00:30:24,089 --> 00:30:25,769
if we want it to
be cached or not,

716
00:30:25,769 --> 00:30:27,569
we have to enable
something called swapping.

717
00:30:27,569 --> 00:30:30,090
All right, so I'm going to
show how we can do swapping.

718
00:30:30,090 --> 00:30:31,369
And then finally, I want to

719
00:30:31,369 --> 00:30:32,950
show how we can set up doctors

720
00:30:32,950 --> 00:30:36,030
that a container has
limited memory consumption.

721
00:30:36,030 --> 00:30:38,030
All right, so first I'm
going to start with the CPU.

722
00:30:38,030 --> 00:30:39,350
And remember that the CPU

723
00:30:39,350 --> 00:30:41,329
typically we'll have
three levels of caching,

724
00:30:41,329 --> 00:30:42,970
L1l2 and L three.

725
00:30:42,970 --> 00:30:44,569
And I want to see how

726
00:30:44,569 --> 00:30:46,470
data is actually being
accessed in there.

727
00:30:46,470 --> 00:30:48,189
And so one of the
policy questions

728
00:30:48,189 --> 00:30:50,470
was when we should evict things,

729
00:30:50,470 --> 00:30:52,709
right, or when we should
load things into the cache.

730
00:30:52,709 --> 00:30:57,770
Another question is if I just
access one byte of data,

731
00:30:57,770 --> 00:30:59,769
say it's like a
letter in a string,

732
00:30:59,769 --> 00:31:02,689
would I just bring that letter
by itself into the cache?

733
00:31:02,689 --> 00:31:04,869
Or would I bring maybe
like the whole string or

734
00:31:04,869 --> 00:31:07,340
some other amount of data?

735
00:31:07,340 --> 00:31:09,159
And there's a bit of a
trade off here, right?

736
00:31:09,159 --> 00:31:11,139
If I just access a
small bit of data and

737
00:31:11,139 --> 00:31:12,539
that small bit of data
is the only thing

738
00:31:12,539 --> 00:31:14,399
I read into the cache.

739
00:31:14,399 --> 00:31:15,500
Then pretty soon I'm

740
00:31:15,500 --> 00:31:16,660
probably going to
read the next letter.

741
00:31:16,660 --> 00:31:18,459
And then I'd have another
cache miss and another one.

742
00:31:18,459 --> 00:31:20,860
Right? So if you go
too fine grained,

743
00:31:20,860 --> 00:31:23,580
your cache will probably
have a lot of Mrs.

744
00:31:23,580 --> 00:31:24,960
Right. On the other hand,

745
00:31:24,960 --> 00:31:27,819
if I access this
tiny little bite

746
00:31:27,819 --> 00:31:29,919
and I pull in like
a whole megabyte,

747
00:31:29,919 --> 00:31:32,479
well, I'm probably not
like that surrounds it.

748
00:31:32,479 --> 00:31:34,260
I'm probably not going to
use most of that data.

749
00:31:34,260 --> 00:31:35,839
So that's wasteful too, right?

750
00:31:35,839 --> 00:31:38,219
So there's some kind of
granularity or sweet spot that we

751
00:31:38,219 --> 00:31:40,779
try to go for and
the name for that,

752
00:31:40,779 --> 00:31:42,899
for that amount of
data that we pull in.

753
00:31:42,899 --> 00:31:46,619
It's generally fixed. It's
called a cache line, right?

754
00:31:46,619 --> 00:31:48,759
So modern CPU's typically have

755
00:31:48,759 --> 00:31:50,940
a cache line of 64 bytes, right?

756
00:31:50,940 --> 00:31:52,719
So if I read one byte string up,

757
00:31:52,719 --> 00:31:54,559
pull in 64 bytes,

758
00:31:54,559 --> 00:31:56,079
a 64 byte chunk of

759
00:31:56,079 --> 00:31:58,360
memory that reads it
into the cache, right?

760
00:31:58,360 --> 00:32:01,000
You know, older CPUs

761
00:32:01,000 --> 00:32:03,620
sometimes would have bigger
or smaller cache lines.

762
00:32:03,620 --> 00:32:05,919
Again, it's not like bigger
or smaller is better, right?

763
00:32:05,919 --> 00:32:07,300
It kind of depends on
what you're doing.

764
00:32:07,300 --> 00:32:08,680
There's some kind of sweet spot.

765
00:32:08,680 --> 00:32:10,539
For a long time,
most modern CPUs are

766
00:32:10,539 --> 00:32:12,719
64 apples experimenting now.

767
00:32:12,719 --> 00:32:15,200
Like in their latest max,
they're trying 128 again,

768
00:32:15,200 --> 00:32:17,619
so kind of bringing that
back, that size, right?

769
00:32:17,619 --> 00:32:19,760
But you could kind of the
order of magnitude, right?

770
00:32:19,760 --> 00:32:21,460
We're not talking
like kilobytes,

771
00:32:21,460 --> 00:32:25,660
we're talking about 100 or
so bytes at the most, right?

772
00:32:25,660 --> 00:32:30,699
How big is that? Well,
64 has eight bytes,

773
00:32:30,699 --> 00:32:38,700
and so I could have 864 integers
inside of a cache line.

774
00:32:38,700 --> 00:32:41,339
Let's think about
what this would do in

775
00:32:41,339 --> 00:32:44,680
terms of cache hits
and cache Mrs.

776
00:32:44,680 --> 00:32:47,460
I have three examples
here, right?

777
00:32:47,460 --> 00:32:50,379
In each case, I'm going to
start on the left hand side.

778
00:32:50,379 --> 00:32:52,939
Maybe it's a little bit
of a confusing picture,

779
00:32:52,939 --> 00:32:58,160
but what I'm imagining
is that 1664,

780
00:32:58,160 --> 00:33:01,039
all in memory
following each other.

781
00:33:01,039 --> 00:33:02,100
They're all contiguous, right?

782
00:33:02,100 --> 00:33:05,709
They're all in a row in
memory. I have a program.

783
00:33:05,709 --> 00:33:08,719
That is accessing four numbers.

784
00:33:08,719 --> 00:33:11,080
Maybe my program just
says like A plus

785
00:33:11,080 --> 00:33:13,719
B plus C plus D.
Very simple program.

786
00:33:13,719 --> 00:33:16,180
And so the numbers
that it's accessing,

787
00:33:16,180 --> 00:33:18,000
I put that in bold, red.

788
00:33:18,000 --> 00:33:19,459
And then the numbers
that it's not

789
00:33:19,459 --> 00:33:22,340
accessing right now are black.

790
00:33:22,340 --> 00:33:24,579
Right? See it's accessing
these four numbers.

791
00:33:24,579 --> 00:33:25,940
And then what I've
done is I've drawn

792
00:33:25,940 --> 00:33:27,240
these red boxes around

793
00:33:27,240 --> 00:33:29,980
all the numbers to
indicate a cache line.

794
00:33:29,980 --> 00:33:31,659
Right? So numbers that are on

795
00:33:31,659 --> 00:33:34,380
the same box are part
of the same cash line.

796
00:33:34,380 --> 00:33:36,439
So that's set up.

797
00:33:36,439 --> 00:33:38,459
My question for you
all is this program

798
00:33:38,459 --> 00:33:40,959
that adds A plus
B plus C plus D,

799
00:33:40,959 --> 00:33:42,999
how many hold up some
number of fingers,

800
00:33:42,999 --> 00:33:45,039
how many cache lines are

801
00:33:45,039 --> 00:33:48,479
we going to have to
load in to do this?

802
00:33:57,210 --> 00:34:00,090
I'm seeing very few hands up.

803
00:34:00,090 --> 00:34:01,609
The people who are putting
their hands up are

804
00:34:01,609 --> 00:34:03,549
saying one, which is correct.

805
00:34:03,549 --> 00:34:05,309
Right. All the
numbers I wanted to

806
00:34:05,309 --> 00:34:07,290
access are part of
the same cash line.

807
00:34:07,290 --> 00:34:09,610
Right. So when I access
the first number,

808
00:34:09,610 --> 00:34:10,989
there will be a cash mess.

809
00:34:10,989 --> 00:34:12,509
I'll load in the
whole thing. And then

810
00:34:12,509 --> 00:34:14,390
when I access the
other three numbers,

811
00:34:14,390 --> 00:34:16,389
they're already in the cash.

812
00:34:16,389 --> 00:34:17,929
Right. So I wouldn't
have any more mess.

813
00:34:17,929 --> 00:34:18,969
It's just one cash mess and

814
00:34:18,969 --> 00:34:20,489
I would roll it in
this cash line.

815
00:34:20,489 --> 00:34:22,849
So I'm going to

816
00:34:22,849 --> 00:34:23,889
take some questions
because I think

817
00:34:23,889 --> 00:34:26,130
a lot of people seem confused,

818
00:34:26,130 --> 00:34:29,209
so Any clarifications about how

819
00:34:29,209 --> 00:34:32,710
the cash lines work or about
this specific example?

820
00:34:32,710 --> 00:34:37,610
Yeah, right back here. Load.

821
00:34:44,890 --> 00:34:48,569
Yeah, exactly. Right. So
whatever the eviction policy is,

822
00:34:48,569 --> 00:34:49,969
that whole cash line will get

823
00:34:49,969 --> 00:34:51,909
evicted at the same time, right?

824
00:34:51,909 --> 00:34:53,929
So this is kind of like the
granularity of data that

825
00:34:53,929 --> 00:34:55,170
we used to bring into the cache

826
00:34:55,170 --> 00:34:56,449
and evict out of the cash.

827
00:34:56,449 --> 00:34:59,069
Absolutely. Yep, Yeah,

828
00:34:59,069 --> 00:35:01,249
what other questions
do people have?

829
00:35:03,410 --> 00:35:06,209
All right, let's
try another one.

830
00:35:06,209 --> 00:35:09,350
So in this case I'm just
adding two integers.

831
00:35:09,350 --> 00:35:11,389
Maybe it's like X plus Y.

832
00:35:11,389 --> 00:35:13,290
And I'm wondering, right, if

833
00:35:13,290 --> 00:35:14,529
we start with
nothing in the cash,

834
00:35:14,529 --> 00:35:16,229
how many cash Sss will I be,

835
00:35:16,229 --> 00:35:18,629
will I have in order
to add X plus Y?

836
00:35:18,629 --> 00:35:21,170
Hold up some number of fingers.

837
00:35:29,190 --> 00:35:33,050
I'm seeing a few people
say two, which is correct.

838
00:35:33,050 --> 00:35:36,050
Right. Even though I'm
accessing two numbers,

839
00:35:36,050 --> 00:35:36,949
only two numbers, they are

840
00:35:36,949 --> 00:35:38,049
each and there are
different cash lines.

841
00:35:38,049 --> 00:35:39,369
That means I have to load in

842
00:35:39,369 --> 00:35:42,069
two complete cash lines to
be able to do this, right?

843
00:35:42,069 --> 00:35:46,129
So adding these two numbers
is probably actually a lot

844
00:35:46,129 --> 00:35:48,409
slower than adding four of them

845
00:35:48,409 --> 00:35:50,769
in the previous example.
That makes sense.

846
00:35:50,769 --> 00:35:53,229
What questions do
people have about that?

847
00:35:57,830 --> 00:36:01,450
I'm seeing lots of
confused faces,

848
00:36:01,450 --> 00:36:03,970
but if anybody has
any questions,

849
00:36:03,970 --> 00:36:06,829
that would help the
whole room, I think.

850
00:36:10,370 --> 00:36:13,409
All right. Let's look
at this last case.

851
00:36:13,409 --> 00:36:15,850
In this case, we're accessing
every single number.

852
00:36:15,850 --> 00:36:19,110
How many cash Mrs.
will there be assuming

853
00:36:19,110 --> 00:36:22,809
nothing starts in the
cash? I'm seeing some two.

854
00:36:22,809 --> 00:36:25,469
Which is correct, right?
This one will have two.

855
00:36:25,469 --> 00:36:27,650
Second example and third example

856
00:36:27,650 --> 00:36:29,309
are probably actually
pretty close in

857
00:36:29,309 --> 00:36:32,329
performance because cash
miss is going to be

858
00:36:32,329 --> 00:36:34,169
slower usually than just doing

859
00:36:34,169 --> 00:36:36,650
some simple arithmetic
on the CPU.

860
00:36:36,650 --> 00:36:38,870
All right, so let's
see how this plays

861
00:36:38,870 --> 00:36:43,390
out in real programs.

862
00:36:43,390 --> 00:36:46,290
And I found this great blog
that had this school plot.

863
00:36:46,290 --> 00:36:47,249
I'm just trying to borrow that.

864
00:36:47,249 --> 00:36:48,129
I don't think I could have

865
00:36:48,129 --> 00:36:50,230
come up with anything
better myself.

866
00:36:50,230 --> 00:36:52,130
Is it just like a
one line example?

867
00:36:52,130 --> 00:36:54,330
But it shows a huge
difference in performance.

868
00:36:54,330 --> 00:36:55,550
So what is this program?

869
00:36:55,550 --> 00:36:57,250
I think this isn't like C sharp

870
00:36:57,250 --> 00:36:59,309
or some other language,
but we can still read it.

871
00:36:59,309 --> 00:37:01,430
We see we have a loop
that goes from position

872
00:37:01,430 --> 00:37:04,270
zero up until the
length of some array.

873
00:37:04,270 --> 00:37:08,319
And I guess like you could
have plus equal one,

874
00:37:08,319 --> 00:37:10,379
but here it's plus
equal k. And in

875
00:37:10,379 --> 00:37:12,779
the blog posts they
change what is right?

876
00:37:12,779 --> 00:37:17,100
So I might index is like 01234.

877
00:37:17,100 --> 00:37:18,819
Or if k is two,

878
00:37:18,819 --> 00:37:21,239
then I would go 0246.

879
00:37:21,239 --> 00:37:27,560
Right? So I'm doing that quick
background, these are 32.

880
00:37:27,560 --> 00:37:34,260
32. How many bytes are in 3024?

881
00:37:34,260 --> 00:37:36,839
I'm seeing some four, which
is correct. So how many?

882
00:37:36,839 --> 00:37:39,019
32. Can I fit in a cash line?

883
00:37:39,019 --> 00:37:41,659
Somebody can just shout it out.

884
00:37:42,060 --> 00:37:45,459
I heard a couple of people
say 16, which is correct.

885
00:37:45,459 --> 00:37:48,340
Right? It's like
cash lines 64 bytes,

886
00:37:48,340 --> 00:37:50,160
four bytes for each
of these integers.

887
00:37:50,160 --> 00:37:52,859
So each cache line
has 16 of these.

888
00:37:52,859 --> 00:37:56,140
Okay, so let's think
about what happens.

889
00:37:56,140 --> 00:37:58,400
We're looping over
this big array

890
00:37:58,400 --> 00:38:01,180
and whenever we
land on a number,

891
00:38:01,180 --> 00:38:03,899
we multiply it by three.

892
00:38:04,380 --> 00:38:09,859
The bigger the K, the
less work we do, right?

893
00:38:10,220 --> 00:38:13,099
If I make k twice as big,

894
00:38:13,099 --> 00:38:15,379
I only have to look at half as

895
00:38:15,379 --> 00:38:18,379
many integers until I get
to the end of the ray,

896
00:38:18,379 --> 00:38:19,700
right? So what happens?

897
00:38:19,700 --> 00:38:24,439
So what we do is we measure
on the x axis what k is.

898
00:38:24,439 --> 00:38:28,259
Then on the y axis, we see
how long it takes to do so.

899
00:38:28,259 --> 00:38:30,659
What's really interesting
is you go from one.

900
00:38:30,659 --> 00:38:35,379
Up until 16. You're
doing a lot less

901
00:38:35,379 --> 00:38:37,999
multiplying but
it doesn't matter

902
00:38:37,999 --> 00:38:41,200
because what dominates
performance is your cash Mrs.

903
00:38:41,200 --> 00:38:44,679
Right multiplying, that's
fast cash Mrs. slow

904
00:38:44,679 --> 00:38:48,760
and cash line is 16 integer.

905
00:38:48,760 --> 00:38:51,239
So anywhere 1-16 you

906
00:38:51,239 --> 00:38:53,819
have the same number of
cash Mrs. only after that.

907
00:38:53,819 --> 00:38:55,720
Let's say I go up to 32,

908
00:38:55,720 --> 00:38:58,779
then that means I can
access this cash line,

909
00:38:58,779 --> 00:39:01,479
skip one, access a
cash line skip one,

910
00:39:01,479 --> 00:39:03,620
and then all of a sudden
I can be a lot faster.

911
00:39:03,620 --> 00:39:05,399
All right, so what do
you want to start doing?

912
00:39:05,399 --> 00:39:07,239
Start thinking in terms of not

913
00:39:07,239 --> 00:39:08,680
the variables you're accessing.

914
00:39:08,680 --> 00:39:11,390
How many cash lines is
your program accessing?

915
00:39:11,390 --> 00:39:13,799
Don't just think about the
math you're doing on it,

916
00:39:13,799 --> 00:39:15,079
because what really is often

917
00:39:15,079 --> 00:39:18,319
slow is those memory accesses.

918
00:39:18,319 --> 00:39:20,579
All right? Yeah, I thought
it was a very cool plot.

919
00:39:20,579 --> 00:39:23,960
Any, any questions about
the plot experiment?

920
00:39:24,480 --> 00:39:28,959
All right. Yeah, right here.

921
00:39:32,640 --> 00:39:34,860
Oh yeah, that's a good question.

922
00:39:34,860 --> 00:39:36,619
So there's ways that you
can just directly look up.

923
00:39:36,619 --> 00:39:38,359
You can say on this
computer like like what

924
00:39:38,359 --> 00:39:40,559
is the cash line size,
right? So you can do that.

925
00:39:40,559 --> 00:39:42,159
And then here, right,

926
00:39:42,159 --> 00:39:43,660
I guess if I didn't
know that information,

927
00:39:43,660 --> 00:39:45,720
I think you could also infer

928
00:39:45,720 --> 00:39:48,779
that the cash line
is 64 bytes, right?

929
00:39:48,779 --> 00:39:50,720
So, so you could do
this little experiment

930
00:39:50,720 --> 00:39:52,979
and you could try to see
what is really going on,

931
00:39:52,979 --> 00:39:54,639
right? Yeah, great question.

932
00:39:54,639 --> 00:39:57,239
You could do like a little
detective work, right?

933
00:39:57,280 --> 00:40:00,020
All right, so that
was one example.

934
00:40:00,020 --> 00:40:01,519
Just trying to illustrate
it. Let's look

935
00:40:01,519 --> 00:40:02,640
at something that's
more realistic.

936
00:40:02,640 --> 00:40:04,499
That we might
actually want to do

937
00:40:04,499 --> 00:40:07,719
lots of things that

938
00:40:07,719 --> 00:40:09,519
you might be working
with matrices, right?

939
00:40:09,519 --> 00:40:11,879
Like num pi or pitorch
or whatever, right?

940
00:40:11,879 --> 00:40:13,780
It's all kind of similar.

941
00:40:13,780 --> 00:40:16,500
And when I create a matrix,

942
00:40:16,500 --> 00:40:18,479
I think of it as two
dimensional, right?

943
00:40:18,479 --> 00:40:19,919
Maybe I think of
it as a bunch of

944
00:40:19,919 --> 00:40:23,239
rows stacked on top
of each other, right?

945
00:40:23,239 --> 00:40:25,200
So in my mind it's
two dimensional.

946
00:40:25,200 --> 00:40:28,099
But when I put data
in actual Ram,

947
00:40:28,099 --> 00:40:30,159
Ram is just one
dimensional, right?

948
00:40:30,159 --> 00:40:31,740
I put one bite after another.

949
00:40:31,740 --> 00:40:33,600
So this is what I
kind of imagine.

950
00:40:33,600 --> 00:40:36,979
But when I look at a virtual
addrespace'sj, you know,

951
00:40:36,979 --> 00:40:41,159
one row laid one
after another, right?

952
00:40:41,159 --> 00:40:43,539
They just kind of more
all consecutive, right?

953
00:40:43,539 --> 00:40:45,119
So that's how things
would actually get

954
00:40:45,119 --> 00:40:47,060
laid out in my virtual
address space.

955
00:40:47,060 --> 00:40:48,779
Now I want to think
about what would

956
00:40:48,779 --> 00:40:50,879
happen as I'm doing
different operations.

957
00:40:50,879 --> 00:40:53,459
Sometimes I might
want to look in

958
00:40:53,459 --> 00:40:56,559
a single row and add up
all the numbers in a row.

959
00:40:56,559 --> 00:41:00,079
If I'm doing that,
that's a fast operation

960
00:41:00,079 --> 00:41:05,360
because each of these rows
is using consecutive bytes.

961
00:41:05,360 --> 00:41:09,179
And every time I have to
read in a cache line,

962
00:41:09,179 --> 00:41:10,859
it's going to contain
a bunch of numbers in

963
00:41:10,859 --> 00:41:13,519
the same row which I
need for my calculation.

964
00:41:13,519 --> 00:41:14,780
Right? So I can very quickly

965
00:41:14,780 --> 00:41:16,279
add up all the numbers in a row.

966
00:41:16,279 --> 00:41:18,599
That's a cash
friendly thing to do.

967
00:41:18,599 --> 00:41:21,019
Now what's not as

968
00:41:21,019 --> 00:41:26,060
great is if I want to add up
all the numbers in a column,

969
00:41:26,060 --> 00:41:29,379
because what will that mean?

970
00:41:29,379 --> 00:41:30,879
That means that I
have to look at

971
00:41:30,879 --> 00:41:32,319
one value in this row

972
00:41:32,319 --> 00:41:33,879
and one value over
here in this row,

973
00:41:33,879 --> 00:41:35,999
one value in this
row, like each time I

974
00:41:35,999 --> 00:41:38,819
jump so far that I'm in a
different cash line, right?

975
00:41:38,819 --> 00:41:41,840
Each time I'm
loading in 64 bytes,

976
00:41:41,840 --> 00:41:43,939
then I only use like

977
00:41:43,939 --> 00:41:46,559
four bytes of that as
part of my calculation.

978
00:41:46,559 --> 00:41:48,799
Adding all the numbers
in a row, fast,

979
00:41:48,799 --> 00:41:50,240
all the numbers in a column,

980
00:41:50,240 --> 00:41:53,180
that's slow, even if
it's a square matrix.

981
00:41:53,180 --> 00:41:56,379
Okay, Does that make sense?

982
00:41:56,379 --> 00:41:58,299
Why one way is faster
than the other?

983
00:41:58,299 --> 00:42:00,819
Do people have any
questions about that?

984
00:42:02,660 --> 00:42:06,239
All right, so what
can you do about it?

985
00:42:06,239 --> 00:42:08,579
Well, there's different
ways you can create

986
00:42:08,579 --> 00:42:11,459
your tensors or
rays, or matrices.

987
00:42:11,459 --> 00:42:14,259
One way you could do it, I
have two different ways.

988
00:42:14,259 --> 00:42:15,839
I'm create exactly
the same thing.

989
00:42:15,839 --> 00:42:20,719
On the left hand side, I
have this one where 123456,

990
00:42:20,719 --> 00:42:22,559
if I just do it like
that, it's trying to

991
00:42:22,559 --> 00:42:24,699
lay row after row after row.

992
00:42:24,699 --> 00:42:27,859
Now, we talked earlier
on how you know,

993
00:42:27,859 --> 00:42:31,300
Pytorch, a lot of these things
have a transpose feature.

994
00:42:31,300 --> 00:42:33,500
When you transpose a matrix,

995
00:42:33,500 --> 00:42:35,719
they don't want to have to
create a copy of the data.

996
00:42:35,719 --> 00:42:37,939
That's a little bit
wasteful, right?

997
00:42:37,939 --> 00:42:40,700
So what happens when
I transpose a matrix?

998
00:42:40,700 --> 00:42:42,700
They just create like
a small little object

999
00:42:42,700 --> 00:42:44,819
that just says, oh, what am I?

1000
00:42:44,819 --> 00:42:47,059
I'm that matrix over
there transposed.

1001
00:42:47,059 --> 00:42:51,419
And so if you look up in
me coordinates at x Y,

1002
00:42:51,419 --> 00:42:52,679
I'll just look at that one and

1003
00:42:52,679 --> 00:42:54,820
I'll tell you the value at yx.

1004
00:42:54,820 --> 00:42:57,360
Transposing does not
change memory layout,

1005
00:42:57,360 --> 00:42:59,099
it just adds a small
little piece of

1006
00:42:59,099 --> 00:43:01,639
information that it remembers
that it was transposed.

1007
00:43:01,639 --> 00:43:04,440
Okay, so we can take advantage
that's useful of itself,

1008
00:43:04,440 --> 00:43:05,819
but we can take advantage of it.

1009
00:43:05,819 --> 00:43:08,399
There's a trick we can do.
So what we could do is we

1010
00:43:08,399 --> 00:43:11,860
could take our column value.

1011
00:43:11,860 --> 00:43:15,519
In the column I have 135 and
I could put it in a row,

1012
00:43:15,519 --> 00:43:16,319
and I could take

1013
00:43:16,319 --> 00:43:17,899
the other column and I
could put it in a row,

1014
00:43:17,899 --> 00:43:22,879
and I create a tensor and
then I could transpose it.

1015
00:43:22,879 --> 00:43:25,259
All right? So I tell it,

1016
00:43:25,259 --> 00:43:26,740
oh, here are these rows.

1017
00:43:26,740 --> 00:43:28,499
Make sure they're
consecutive in memory.

1018
00:43:28,499 --> 00:43:30,620
And I'm like ha ha, that
row is actually a column,

1019
00:43:30,620 --> 00:43:31,839
but it won't want
to move it just

1020
00:43:31,839 --> 00:43:33,059
because I transposed it.

1021
00:43:33,059 --> 00:43:34,879
So if I do it like this, then

1022
00:43:34,879 --> 00:43:36,380
it'll be laid out in memory,

1023
00:43:36,380 --> 00:43:38,499
one column followed by

1024
00:43:38,499 --> 00:43:41,119
other column. Yeah, a
question right here.

1025
00:43:41,840 --> 00:43:45,239
Yeah, it should be a
constant time, right?

1026
00:43:45,239 --> 00:43:47,020
Maybe there's like
other packages

1027
00:43:47,020 --> 00:43:48,600
that are not but like Insight,

1028
00:43:48,600 --> 00:43:50,119
Pitorch or Numpy, it'll be

1029
00:43:50,119 --> 00:43:51,299
a constant time because

1030
00:43:51,299 --> 00:43:52,699
it's not actually
doing any real work.

1031
00:43:52,699 --> 00:43:54,259
Absolutely, I agree with you.

1032
00:43:54,259 --> 00:43:56,800
Yeah, and that's valuable
in and of itself.

1033
00:43:56,800 --> 00:43:58,579
Plus it's valuable
for this trick.

1034
00:43:58,579 --> 00:44:00,879
Yeah, thank you for
calling that out.

1035
00:44:00,879 --> 00:44:04,139
Other questions people
have about this trick,

1036
00:44:04,139 --> 00:44:06,919
you can take control
of it, right.

1037
00:44:09,660 --> 00:44:11,880
In the end, right? I created

1038
00:44:11,880 --> 00:44:13,339
this tensor in two
different ways.

1039
00:44:13,339 --> 00:44:16,119
Any math I do on it or any
calculations I do with it,

1040
00:44:16,119 --> 00:44:18,680
I'm always trying to get
exactly the same values,

1041
00:44:18,680 --> 00:44:21,919
but they're good at different
kinds of operations.

1042
00:44:21,919 --> 00:44:24,259
All right, so what you can do
is you can think about it.

1043
00:44:24,259 --> 00:44:25,459
Am I going to be
looking at a lot of

1044
00:44:25,459 --> 00:44:27,100
rows or a lot of columns?

1045
00:44:27,100 --> 00:44:28,439
And then you can choose, you can

1046
00:44:28,439 --> 00:44:29,739
have some control
over how you want

1047
00:44:29,739 --> 00:44:32,819
to lay out your data to
get good performance.

1048
00:44:32,819 --> 00:44:36,819
All right, what questions
people have about that trek?

1049
00:44:37,220 --> 00:44:39,899
All right, great
trick when you're

1050
00:44:39,899 --> 00:44:42,340
working with
matrices of numbers,

1051
00:44:42,340 --> 00:44:44,779
right, Which is often
a lot of what we do.

1052
00:44:44,779 --> 00:44:46,519
We're also often working with

1053
00:44:46,519 --> 00:44:48,260
other data types like strings,

1054
00:44:48,260 --> 00:44:51,239
Strings I think could
even trickier, right?

1055
00:44:51,239 --> 00:44:54,119
So on this picture I'm showing
three different ways that

1056
00:44:54,119 --> 00:44:56,980
I could organize a
list of strings.

1057
00:44:56,980 --> 00:44:58,360
I guess I might call
it a collection

1058
00:44:58,360 --> 00:44:59,999
because maybe it's an
array, maybe it's a list.

1059
00:44:59,999 --> 00:45:01,479
Whatever different
ways I could have

1060
00:45:01,479 --> 00:45:03,379
a sequence of strings, a, B,

1061
00:45:03,379 --> 00:45:06,999
and C. The first ways I can
have a linked list, right?

1062
00:45:06,999 --> 00:45:08,590
I could have like a
little node object.

1063
00:45:08,590 --> 00:45:10,599
It could contain a,
and then it could have

1064
00:45:10,599 --> 00:45:12,899
a pointer or a reference
over to the next one.

1065
00:45:12,899 --> 00:45:14,459
That could contain B,
and then that could have

1066
00:45:14,459 --> 00:45:17,159
a pointer to the next one.
I could lay those out.

1067
00:45:17,160 --> 00:45:20,320
Maybe I could have
a compact array

1068
00:45:20,320 --> 00:45:22,220
of references to strings

1069
00:45:22,220 --> 00:45:24,280
that are showing up
in different places.

1070
00:45:24,280 --> 00:45:26,379
Or maybe I could just lay out

1071
00:45:26,379 --> 00:45:31,239
all my strings one after the
other in the same place.

1072
00:45:31,239 --> 00:45:35,340
Which of these is going to
be the most cash friendly?

1073
00:45:35,340 --> 00:45:40,679
Yeah, I see a few people.

1074
00:45:40,679 --> 00:45:43,740
Maybe somebody can just
raise their hand and vote.

1075
00:45:43,740 --> 00:45:46,319
Yeah. Do you want to say Yeah,

1076
00:45:46,319 --> 00:45:48,320
I think the last one will
be most cash friendly.

1077
00:45:48,320 --> 00:45:50,800
Right. Because if I'm
accessing all these strings,

1078
00:45:50,800 --> 00:45:52,639
right, then they're
going to fit into

1079
00:45:52,639 --> 00:45:54,579
the fewest possible
cache lines, right?

1080
00:45:54,579 --> 00:45:58,159
Length lists are so
awful for caches, right?

1081
00:45:58,159 --> 00:45:59,639
Because it's almost like
you're guaranteed you're

1082
00:45:59,639 --> 00:46:02,399
always jumping to a different
cache line here and there.

1083
00:46:02,399 --> 00:46:05,819
This second one down
here is what you're

1084
00:46:05,819 --> 00:46:09,019
generally going to see like
in Java or Python, right?

1085
00:46:09,019 --> 00:46:10,299
That you generally
have a array and

1086
00:46:10,299 --> 00:46:11,939
it just has references
to somewhere else.

1087
00:46:11,939 --> 00:46:13,239
Really, the only
time you would have

1088
00:46:13,239 --> 00:46:14,479
like a fast array is when it

1089
00:46:14,479 --> 00:46:17,839
contains primitive values
that are in line, right?

1090
00:46:17,839 --> 00:46:19,840
That last one is the fastest,

1091
00:46:19,840 --> 00:46:22,139
but there's lots of

1092
00:46:22,139 --> 00:46:24,659
questions about how you
actually pull that off.

1093
00:46:24,659 --> 00:46:27,179
If I lay all the strings
like end to end,

1094
00:46:27,179 --> 00:46:28,459
like how do I tell like

1095
00:46:28,459 --> 00:46:30,739
this string ended and
the next one began?

1096
00:46:30,739 --> 00:46:37,099
If I want to say like grab
the string at index five,

1097
00:46:37,099 --> 00:46:39,019
that's kind of a hard
thing to do, right?

1098
00:46:39,019 --> 00:46:40,679
Because each of these strings
has a different length,

1099
00:46:40,679 --> 00:46:42,819
it's hard to calculate
where it is.

1100
00:46:42,819 --> 00:46:45,260
And then finally, with strings,

1101
00:46:45,260 --> 00:46:48,799
we often will have like
none or null values, right?

1102
00:46:48,799 --> 00:46:50,239
That's a very
natural thing to do

1103
00:46:50,239 --> 00:46:51,839
when you have an
array of references.

1104
00:46:51,839 --> 00:46:54,559
But how do I represent
that in here?

1105
00:46:54,559 --> 00:46:57,060
Right, So in general,
when you're programming,

1106
00:46:57,060 --> 00:46:58,920
you don't often end up
with this nice scenario

1107
00:46:58,920 --> 00:47:00,759
that you would like, right?

1108
00:47:00,759 --> 00:47:04,400
And so then enter per
little history on Pero.

1109
00:47:04,400 --> 00:47:07,120
It was started by the
person who made pandas.

1110
00:47:07,120 --> 00:47:09,740
How I know like people come
out of 320 have Don Panda.

1111
00:47:09,740 --> 00:47:11,060
How many people have
like some pandas

1112
00:47:11,060 --> 00:47:12,810
experience prior to this course?

1113
00:47:12,810 --> 00:47:14,609
So maybe half of you, right?

1114
00:47:14,609 --> 00:47:16,390
Pandas has lots of
great features.

1115
00:47:16,390 --> 00:47:19,529
It's fairly easy to use, right?

1116
00:47:19,529 --> 00:47:21,369
And it's really like, they're
just trying to make it

1117
00:47:21,369 --> 00:47:23,409
easy to jump in and start
messing around with data.

1118
00:47:23,409 --> 00:47:24,889
And I think that performance was

1119
00:47:24,889 --> 00:47:26,869
kind of considered
like after the fact.

1120
00:47:26,869 --> 00:47:28,309
So Piero started by

1121
00:47:28,309 --> 00:47:30,210
the same person with a
different perspective

1122
00:47:30,210 --> 00:47:33,809
of let's just make sure
everything is really, you know,

1123
00:47:33,809 --> 00:47:35,229
cash efficient and takes

1124
00:47:35,229 --> 00:47:37,730
advantage of the
latest CPU features,

1125
00:47:37,730 --> 00:47:39,069
all this stuff and they

1126
00:47:39,069 --> 00:47:40,189
haven't added all
these features but

1127
00:47:40,189 --> 00:47:41,249
if you're doing
something that were

1128
00:47:41,249 --> 00:47:42,510
performance really matters,

1129
00:47:42,510 --> 00:47:44,689
Piero would be much
better than say

1130
00:47:44,689 --> 00:47:46,369
pandas maybe eventually they'll

1131
00:47:46,369 --> 00:47:48,470
converge and we'll have
the best of both worlds.

1132
00:47:48,470 --> 00:47:50,490
So they have lots of
different data structures

1133
00:47:50,490 --> 00:47:52,450
called a rays for
different types.

1134
00:47:52,450 --> 00:47:55,130
And then they can have
tables where the table,

1135
00:47:55,130 --> 00:47:57,350
each column is one
of these arrays.

1136
00:47:57,350 --> 00:47:58,689
So let me just show you how they

1137
00:47:58,689 --> 00:48:00,990
would implement a string array.

1138
00:48:00,990 --> 00:48:03,530
They would take a few
different regions

1139
00:48:03,530 --> 00:48:05,550
of consecutive memory.

1140
00:48:05,550 --> 00:48:08,390
The first one looks like what
we saw in the last slide.

1141
00:48:08,390 --> 00:48:10,009
They would take all
the strings and

1142
00:48:10,009 --> 00:48:12,069
just lay them end
to end like this.

1143
00:48:12,069 --> 00:48:15,009
And that looks the same
as up here, right?

1144
00:48:15,009 --> 00:48:17,249
So Fubo bar and
all baths, right?

1145
00:48:17,249 --> 00:48:19,949
That's what they would
lay out down here.

1146
00:48:19,949 --> 00:48:23,449
But then they want to be
able to quickly tell you,

1147
00:48:23,449 --> 00:48:25,849
give me the string
at index five.

1148
00:48:25,849 --> 00:48:26,969
And so what they'll
do is they'll have

1149
00:48:26,969 --> 00:48:29,590
another region of
consecutive memory.

1150
00:48:29,590 --> 00:48:31,109
And they'll say the first string

1151
00:48:31,109 --> 00:48:33,569
is from index zero to three.

1152
00:48:33,569 --> 00:48:36,489
The next string is from
index three to six.

1153
00:48:36,489 --> 00:48:38,709
And then so on and so
forth, right that straight.

1154
00:48:38,709 --> 00:48:40,529
Because they can quickly jump in

1155
00:48:40,529 --> 00:48:43,750
here and find a string
at a specific position,

1156
00:48:43,750 --> 00:48:44,849
they can figure out where

1157
00:48:44,849 --> 00:48:45,949
is the start and
end of that string.

1158
00:48:45,949 --> 00:48:47,429
So the strings are consecutive,

1159
00:48:47,429 --> 00:48:49,789
and then these indexes
are consecutive.

1160
00:48:49,789 --> 00:48:52,170
And then the last piece is
that they want to support.

1161
00:48:52,170 --> 00:48:54,949
All right, and so
how do they do that?

1162
00:48:54,949 --> 00:48:56,629
They have something
called a bit map.

1163
00:48:56,629 --> 00:48:58,790
The bitmap has ones and zeros.

1164
00:48:58,790 --> 00:49:00,410
Ones means it's valid,

1165
00:49:00,410 --> 00:49:01,890
zero means it's not valid.

1166
00:49:01,890 --> 00:49:03,889
So not valid means it's
like a null or none.

1167
00:49:03,889 --> 00:49:05,249
So reading this from the left,

1168
00:49:05,249 --> 00:49:07,510
I see there's four
ballads and then a null.

1169
00:49:07,510 --> 00:49:08,829
And that's the same as up here,

1170
00:49:08,829 --> 00:49:11,270
there's four ballads
and then a null.

1171
00:49:11,270 --> 00:49:13,550
Right? Some other details,
they have padding.

1172
00:49:13,550 --> 00:49:15,269
Padding is just sites
that aren't used for

1173
00:49:15,269 --> 00:49:17,249
anything and so they had

1174
00:49:17,249 --> 00:49:19,409
this bite for the bit
map and then they

1175
00:49:19,409 --> 00:49:21,790
had 63 bytes over
here for padding.

1176
00:49:21,790 --> 00:49:24,390
Does that ring a bell?
Why do you think it's 63?

1177
00:49:24,390 --> 00:49:29,229
Any guesses? Yeah, right here.

1178
00:49:29,229 --> 00:49:30,729
The length of a cash line,

1179
00:49:30,729 --> 00:49:31,949
the length of a
cash line, right?

1180
00:49:31,949 --> 00:49:33,109
If you had these
together, they're

1181
00:49:33,109 --> 00:49:34,189
going to add up to a cash line.

1182
00:49:34,189 --> 00:49:35,609
And so their data
is going to start

1183
00:49:35,609 --> 00:49:37,749
right at the boundary
of a cash line, right?

1184
00:49:37,749 --> 00:49:39,489
So they built this
and so they are just

1185
00:49:39,489 --> 00:49:41,729
from the start thinking about
how can we lay things out.

1186
00:49:41,729 --> 00:49:44,510
So it's straightforward
in memory.

1187
00:49:44,510 --> 00:49:47,209
So next time I don't have
time to dig into now,

1188
00:49:47,209 --> 00:49:48,550
but next time I'll
do some examples.

1189
00:49:48,550 --> 00:49:49,590
How can we use Pierro?

1190
00:49:49,590 --> 00:49:50,749
Work with some data and get

1191
00:49:50,749 --> 00:49:53,709
some better performance
using that.

1192
00:49:53,709 --> 00:49:57,030
Alright grey. Have an
awesome afternoon.
